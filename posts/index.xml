<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 개발자 지호</title><link>/posts/</link><description>Recent content in Posts on 개발자 지호</description><generator>Hugo -- gohugo.io</generator><copyright>&amp;copy; 2021 &lt;a href="4ppl3Hun73r.github.io/">지호&lt;/a></copyright><lastBuildDate>Sat, 16 May 2020 00:00:00 +0900</lastBuildDate><atom:link href="/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>분산 시스템 추적 시스템</title><link>/posts/2020/05/distributedtracing/</link><pubDate>Sat, 16 May 2020 00:00:00 +0900</pubDate><guid>/posts/2020/05/distributedtracing/</guid><description>이전 포스팅에서 MDC 를 이용한 로그를 남기고 여러 시스템간의 로그를 추적하는 기능에 대해서 포스팅을 했었다. Slf4j Mapped Diagnostic Context (MDC) 를 이용한 사용자 요청 추적 나중에 확인해 보니 이미 MSA 환경</description></item><item><title>nginx resource logging disable 처리</title><link>/posts/2020/03/nginxresourcelogdisable/</link><pubDate>Sat, 14 Mar 2020 00:00:00 +0900</pubDate><guid>/posts/2020/03/nginxresourcelogdisable/</guid><description>문제점 css, js, png 같은 정적 자원들이 log 에 표시되는걸 없애고 싶다 Nginx Log 제어 방법 공식문서, logging conditional map $uri $name { .(css|js|png)$ 0; default 1; } access_log logs/access.log main if=$loggable; or set $loggable 1; access_log logs/access.log main if=$loggable; if ($uri ~* &amp;quot;.(css|js|png)$&amp;quot;) { set $loggable 0; }</description></item><item><title>zookeeper 를 이용한 leader / client 구조 개발</title><link>/posts/2021/03/zookeeperpractice/</link><pubDate>Sun, 01 Mar 2020 00:00:00 +0900</pubDate><guid>/posts/2021/03/zookeeperpractice/</guid><description>JAVA 환경에서 여러 서버의 상태를 관리해야 하는 일이 생겼다. 현재 스펙 각 서버는 각자의 처리량을 가지고 있다. 기존 방식은 처리량을 redis에 저장하고 각자의 서버들이 red</description></item><item><title>Slf4j Mapped Diagnostic Context (MDC) 를 이용한 사용자 요청 추적</title><link>/posts/2020/02/slf4jmdclogging/</link><pubDate>Sat, 22 Feb 2020 00:00:00 +0900</pubDate><guid>/posts/2020/02/slf4jmdclogging/</guid><description>문제점 특정 에러 로그를 봤을떄 에러의 시작점을 찾기까지 추적하는데 불편함을 느낌 개선 아이디어 사용자의 요청 마다 Unique ID 를 발급하여 로그를 남길때 마다 추가 로그에 찍힌 ID를 가</description></item><item><title>rSocket</title><link>/posts/2020/01/rsocket/</link><pubDate>Sat, 18 Jan 2020 00:00:00 +0900</pubDate><guid>/posts/2020/01/rsocket/</guid><description>Netflix 에서 개발한 Reactive Stream을 기반으로 한 어플리케이션 프로토콜. 마이크로 서비스상에서 Http 통신이 비효율적인 부분이 있기 때문에 오버헤드가 적은 프로토콜로 대체하려는 용</description></item><item><title>애자일 관련 도서 카이젠 저니를 읽고</title><link>/posts/2019/12/kaizenjourneybook/</link><pubDate>Fri, 27 Dec 2019 00:00:00 +0900</pubDate><guid>/posts/2019/12/kaizenjourneybook/</guid><description>일하는 방식에 대해서 고민을 하던중 애자일에 대한 책 한권을 읽어봐야 겠다는 생각이 들어서 관련 도서를 검색하다가 이 책을 발견했다. 한 일주일에 걸쳐서 읽었는데 애자일이 존재하</description></item><item><title>내가 자주 사용하는 Docker Command 정리</title><link>/posts/2019/12/dockercommand/</link><pubDate>Thu, 26 Dec 2019 00:00:00 +0900</pubDate><guid>/posts/2019/12/dockercommand/</guid><description>docker ps -a docker container 보기 docker exec -it {container ID} {exec command} docker 컨테이너에 명령어 실행 $ docker exec -it c903213b1 /bin/bash docker logs {container ID} docker 컨테이너 로그 확인 컨테이너 로그 위치 /var/lib/docker/containers/{container ID}/{container Name}-json.log 컨테이너 로그 지우기 $ truncate -s 0 /var/lib/docker/containers/*/*-json.log</description></item><item><title>Spring One re:Cap Seoul 2019 참석</title><link>/posts/2019/12/springonerecap/</link><pubDate>Thu, 19 Dec 2019 00:00:00 +0900</pubDate><guid>/posts/2019/12/springonerecap/</guid><description>12월 18일에 2019년도 Spring One re:Cap 행사에 참석을 했습니다. 전체적인 순서는 Keynote 정리 -&amp;gt; 기술 세션 정리 -&amp;gt; Live Coding with Mark Heckler -&amp;gt; Apache Geode Summit re:Cap -&amp;gt; Concourse / Spinnaker 로 진행 되었습니다. Live Coding 순서부터 회</description></item><item><title>Nginx 302 Redirect 설정시 Upstream Name으로 이동할때 처리</title><link>/posts/2019/12/nginx302redirectproxysetting/</link><pubDate>Mon, 09 Dec 2019 00:00:00 +0900</pubDate><guid>/posts/2019/12/nginx302redirectproxysetting/</guid><description>upstream target { server 127.0.0.1; ... } ... location / { proxy_pass http://target; } 위와 같이 설정했을때 기본적은 proxy 는 문제 없이 동작하는데 302 처리할때는 url이 http://target 으로 사용자에게 처리되는 경우가 발생했었다. 아래와 같이 h</description></item><item><title>Apache Httpd Module Compile</title><link>/posts/2019/11/apachemodulecompile/</link><pubDate>Sun, 17 Nov 2019 00:00:00 +0900</pubDate><guid>/posts/2019/11/apachemodulecompile/</guid><description>Apache 가 설치되어 있을때 추가로 모듈을 설치해야 할때 Apache Source Code Download Apache Http Server Download Page 에서 httpd-{version}.tar 다운로드 ex) wget http://apache.mirror.cdnetworks.com//httpd/httpd-2.4.41.tar.gz Compile mod_include.so 가 필요할때 컴파일로 모듈 만들기 $APACHE_HOME/bin/apxs -i -a -c $APACHE_SOURCE_HOME/modules/filters/mod_include.c</description></item><item><title>Google Analytics 붙이기</title><link>/posts/2019/11/addgoogleanalytics/</link><pubDate>Sun, 10 Nov 2019 00:00:00 +0900</pubDate><guid>/posts/2019/11/addgoogleanalytics/</guid><description>Google Analytics 계정 만들기 무료 계정 생성 을 통해서 계정을 만든다 생성 자체는 별거 없긴 한데 혹시 모르니 스크린샷을 남겨 놓는다. 생성 이후 GA ID 확인 신규 계정이 생성되고 계정이 생성되자 마</description></item><item><title>puppeteer 동작을 영상으로 녹화 시키기</title><link>/posts/2019/11/puppeteerrecoding/</link><pubDate>Sun, 10 Nov 2019 00:00:00 +0900</pubDate><guid>/posts/2019/11/puppeteerrecoding/</guid><description>puppeteer 를 이용해서 작업을 진행하다 보면 진행사항을 보고 싶은 경우가 있다. 개발 중이거나 테스트시에는 직접 브라우저를 띄워서 볼수 있지만 실제 운영 환경에 적용을 하게 되면 직접 눈으</description></item><item><title>Github Page 를 만들어 보자</title><link>/posts/2019/11/creategithubpage/</link><pubDate>Sat, 09 Nov 2019 00:00:00 +0900</pubDate><guid>/posts/2019/11/creategithubpage/</guid><description>신규 레파지토리 생성 신규 레포파지토리 생성 레파지토리 이름은 반드시 {profile id}.github.io 로 생성해야 한다. GitHub Pages 활성화 각 레파지토리의 세팅 페이지에서 ( ex: https://github.com/4ppl3Hun73r/4ppl3Hun73r.github.io/settings ) 에서 GitHub Pages Theme 를 선택해주게 되</description></item><item><title>개발 블로그를 다시 시작하면서</title><link>/posts/2019/11/createblog/</link><pubDate>Fri, 01 Nov 2019 00:00:00 +0900</pubDate><guid>/posts/2019/11/createblog/</guid><description>taetaetae 님의 개발자가 글을 써야 하는 이유 를 보고 이번에는 제대로 블로그를 해봐야 겠다는 마음으로 블로그를 만드는 것 부터 다시 시작해 봤다. 기존에 운영해 봤던 블로그들에 대한 회고 네</description></item><item><title/><link>/posts/2019/11/vlivechromeextension/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/2019/11/vlivechromeextension/</guid><description>V Live Playlist Chrome Extension 만들기 V Live 를 사용하면서 개인별 playlist가 없다는 점이 아쉬워서 Chrome Extension을 이용해서 직접 기능을 만들어 보기로 했다. 기본 컨셉 유투브의 플</description></item><item><title/><link>/posts/2019/11/vlivechromeextensionrequirement/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/2019/11/vlivechromeextensionrequirement/</guid><description>V Live Playlist Chrome Extension 요구사항 정의 conetent 영역 정의 공유 영역 옆에 버튼 추가 Playlist 추가, PIP 재생 기능을 추가해주는 영역 추가 Playlist 클릭시 동작 정의 Playlist 클릭시 플레이리스트 추가 layer 가 오버 됨 구글의 플레</description></item></channel></rss>